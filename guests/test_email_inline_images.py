import uuid
from django.test import TestCase, override_settings
from django.core import mail
from django.contrib.auth.models import User
from guests.models import Event, Guest, Invitation
from guests.views import send_invitation_email


@override_settings(EMAIL_BACKEND='django.core.mail.backends.locmem.EmailBackend')
class InvitationEmailInlineImagesTests(TestCase):
    def setUp(self):
        # create an organizer user
        self.staff = User.objects.create_user(username='staff2', password='pass')
        self.staff.is_staff = True
        self.staff.save()

        # create the event requested by the user, include program/menu/seating JSON
        self.event = Event.objects.create(
            name='Annual Ball',
            date='2026-01-01T19:00:00',
            location='Grand Hall',
            created_by=self.staff,
            program_schedule={
                "items": [
                    {"time": "7:00 PM", "activity": "Opening Ceremony", "description": "Welcome speech"},
                    {"time": "7:30 PM", "activity": "Dinner Service", "description": "Three-course plated dinner"},
                    {"time": "9:00 PM", "activity": "Awards & Entertainment", "description": "Presentations and performances"}
                ]
            },
            menu={
                "courses": [
                    {"name": "Starter", "items": ["Salad", "Soup"]},
                    {"name": "Main", "items": ["Beef Wellington", "Seared Salmon"]},
                    {"name": "Dessert", "items": ["Chocolate Mousse", "Fruit Tart"]}
                ]
            },
            seating_arrangement={
                "tables": [
                    {"number": "1", "capacity": 8, "section": "VIP"},
                    {"number": "2", "capacity": 8, "section": "General"}
                ]
            },
            has_assigned_seating=True,
        )

        # create the guest
        self.guest = Guest.objects.create(
            first_name='Marriott',
            last_name='Mumba',
            email='marriott.mumba@example.com'
        )

    def test_invitation_email_contains_inline_images_and_cids(self):
        # Create invitation with the specific UUID provided by the user
        code = uuid.UUID('bc01f5af-babb-4837-9d21-753516c44334')
        inv = Invitation.objects.create(event=self.event, guest=self.guest, unique_code=code)

        # Ensure media files were generated by save()
        self.assertTrue(inv.qr_code and inv.qr_code.name)
        self.assertTrue(inv.barcode_image and inv.barcode_image.name)

        # Send the invitation email
        send_invitation_email(inv, request=None)

        # One email should have been sent
        self.assertEqual(len(mail.outbox), 1)
        email = mail.outbox[0]

        # HTML alternative should reference the CIDs we expect
        expected_qr_cid = f"qr-{inv.id}@guesttracker"
        expected_barcode_cid = f"barcode-{inv.id}@guesttracker"

        # The HTML alternative is stored in alternatives; find the HTML
        html = None
        for alt, mimetype in getattr(email, 'alternatives', []):
            if mimetype == 'text/html':
                html = alt
                break
        self.assertIsNotNone(html)

        # Check that HTML references both CIDs and guest/event info
        self.assertIn(f'cid:{expected_qr_cid}', html)
        self.assertIn(f'cid:{expected_barcode_cid}', html)
        # Template uses guest.first_name in greeting, ensure it is present
        self.assertIn('Marriott', html)
        self.assertIn('Annual Ball', html)

        # Inspect the raw email message parts for Content-ID headers
        msg = email.message()
        content_id_values = set()
        image_count = 0
        for part in msg.walk():
            cid = part.get('Content-ID')
            if cid:
                # strip surrounding < > if present
                content_id_values.add(cid.strip())
            ctype = part.get_content_type()
            if ctype.startswith('image/'):
                image_count += 1

        # Expect at least two inline image parts (QR + barcode)
        self.assertGreaterEqual(image_count, 2)

        # Expect our CIDs (with angle brackets) to be present
        self.assertIn(f'<{expected_qr_cid}>', content_id_values)
        self.assertIn(f'<{expected_barcode_cid}>', content_id_values)
